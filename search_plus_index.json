{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"doc/html.html":{"url":"doc/html.html","title":"HTML","keywords":"","body":"HTML 相关 HTML5 的新特性 src 和 href 属性的区别 script 标签中 defer 和 async 的区别 "},"doc/html/html5-new-feature.html":{"url":"doc/html/html5-new-feature.html","title":"HTML5 新特性","keywords":"","body":"HTML5 的新特性 1. DOCTYPE 声明 只是一个说明，用来告诉浏览器当前的html页面是用什么版本的html写的。 html5 中的 DOCTYPE 声明只需要一段。 而 html4 中的声明引用了DTD（document type define），因为 html4.01 是基于 SGML 的，而它引用的 DTD 指明了 html 的规则，从而浏览器能正确的渲染页面。而 html5 不是基于 SGML 所以不需要引用 DTD。 html4 中的声明： ; 2. 语义化标签 html5 新增语义化标签。 标签 标签 文档中定义文章内容 img和figcaption组合放在figure里 一个文档可以有多个footer 一个文档可以有多个header 导航 在文档中定义部分 语义化标签的好处 语义化标签能够方便开发者更好的理解文档，也使得计算机对于文档地理解更加地友好。比如人工智能的语义分析，搜索引擎的搜索分析，辅助视力阅读障碍者的屏幕阅读器之类的软件，在语义化标签的帮助下，能够更好的工作。 3. 新增 input 类型和属性 html 5 新增了一些 input 的类型和属性，对表单有一个增强。 类型type 属性attribute color autocomplete date autofocus datetime form datetime-local formaction email formenctype month formmethod number formnovalidate range formtarget search height and width tel list search min and max time pattern(regexp) url placeholder week required step mutiple 4. 图形标签 新增 和 标签。 SVG 代表可缩放矢量图形，用于 Web 定义图形，本质上是 XML，通过在 XML 中描述路径进行绘制图形。目前页面中很多图片都使用 SVG 进行展示，不失真，并且体积小，加载速度快。 canvas 和 svg 的区别： Canvas SVG 与分辨率相关(可以理解为位图，图形放大会失真看到一个个像素点) 与分辨率无关(可以理解为矢量，图形放大不会失真) 不支持事件处理程序 支持事件处理程序 文字呈现功能比较简单 最适合具有大型渲染区域地应用程序(如Google地图) 可以将生成的图像保存为.png或.jpg 如果复杂地话渲染速度慢(其实任何使用DOM的东西都会很慢) 适合图形密集性游戏 不适合游戏应用程序 5. 多媒体标签 新增 和 标签，实现了对音频和视频的支持。 思考🤔：如何使用 Canvas 实现 视频播放的功能（面试问过） 思路：视频无非也是由一帧一帧的图像连续播放的，因此可以定时捕获视频每一帧的图像，并使用 Canvas 进行绘制，同时还可以添加文字实现弹幕的功能。 6. 新的 API HTML Geolocation 地理位置 HTML Drag & Drop拖放 HTML Local Storage 本地存储 HTML Application Cache 应用程序缓存 HTML Web Workers web工作者 "},"doc/html/diff-between-src-href.html":{"url":"doc/html/diff-between-src-href.html","title":"src 和 href 属性的区别","keywords":"","body":"src 和 href 属性的区别 1. 定义 href 是 Hypertext Reference 的简写，表示超文本引用，指向网络资源所在位置。 src 是 source 简写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置 2. 解析方式 当浏览器遇到 href 会并行下载资源并且不会停止对当前文档的处理。(同时也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式) 当浏览器解析到 src ，会暂停其他资源的下载和处理，直到将该资源加载或执行完毕。(这也是 script 标签为什么放在底部而不是头部的原因) "},"doc/html/diff-between-async-defer.html":{"url":"doc/html/diff-between-async-defer.html","title":"script 标签中 defer 和 async 的区别","keywords":"","body":"script 标签中 defer 和 async 的区别 默认情况下，脚本的下载和执行将会按照文档的先后顺序同步进行。当脚本下载和执行的时候，文档解析就会被阻塞，在脚本下载和执行完成之后文档才能往下继续进行解析。 async 会将 js 的加载与执行文档的加载并行进行 defer 会将 js 的加载与文档加载并行执行，js 的执行在加载之后。 下图展示了区别： "},"doc/html/element-vs-node.html":{"url":"doc/html/element-vs-node.html","title":"Element 和 Node 的区别","keywords":"","body":"Element 和 Node 的区别 在 js 中会经常使用 document.getElementById 去获取 dom 元素，也会使用 childNode 来获取子节点。 二者的区别是什么呢？ 先来看一个简单的例子： Node vs Element Node vs Element node vs element 下面分别打印 标签下的 Element 和 ChildNodes，可以看到，getElement 返回的是 HTMLCollection 对象，而 childNodes 返回的是 NodeList 对象。 那么问题来了： HTMLCollection，NodeList 是啥 NodeList 数组里的 text 又是啥 Node 和 Element定义 先来看看 MDN 上 对 Node 的定义： A Node is an interface from which a number of DOM types inherit, and allows these various types to be treated (or tested) similarly. The following interfaces all inherit from Node its methods and properties: Document, Element, CharacterData (which Text, Comment, and CDATASection inherit), ProcessingInstruction, DocumentFragment, DocumentType, Notation, Entity, EntityReference. 上面两段话到意思就是 Node是一个基类，DOM中的Element，Text和Comment都继承于它。 其实，Node 就是表示的是 DOM 树的结构，在 html 中，节点与节点中间是可以插入文本的，这个插入文本的间隙就是 Text。 HTMLCollection 和 NodeList NodeList是Node的集合，ElementCollection是Element的集合。 但需要特别注意的是： NodeList和ElementCollcetion都不是真正的数组\\ 如果document.getElementsByTagName('a') instanceof Array，结果是false。 "},"doc/css.html":{"url":"doc/css.html","title":"CSS","keywords":"","body":"CSS "},"doc/css/position-layout.html":{"url":"doc/css/position-layout.html","title":"position 布局","keywords":"","body":"position 布局 1、static 默认是static，使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时的top、left等属性设置无效。 2、relative relative 是相对元素正常文档位置的情况下进行布局，使用top、left等属性使其相对原来的位置进行偏移。 3、absolute 绝对定位，脱离文档流布局。通过指定元素最近的非 static 定位元素的偏移，来确定元素定位置。可以设置外边距（margin），且不会与其他边距合并。 4、fixed 不为元素预留空间，而是指定元素相对于 viewport 的位置来制定元素的位置。 5、sticky 相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位 6、inherit 规定应该从父元素继承 position 属性的值。 "},"doc/css/box-model.html":{"url":"doc/css/box-model.html","title":"盒模型","keywords":"","body":"盒模型 所有HTML元素可以看作盒子，在CSS中，\"box model\"这一术语是用来设计和布局时使用。 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 background-color 设置的是 padding 以及 content 的背景色。 IE 盒模型：width = content + border + padding 标准盒模型：width = content /*使用box-sizing选择使用那种盒模型*/ /*content-box 表示标准盒模型，IE 盒模型使用borde-box*/ box-sizing: content-box | border-box; "},"doc/javascript.html":{"url":"doc/javascript.html","title":"JavaScript","keywords":"","body":"JavaScript 相关 "},"doc/javascript/basic/javascript.html":{"url":"doc/javascript/basic/javascript.html","title":"JavaScript 基础","keywords":"","body":"JavaScript 基础 "},"doc/javascript/basic/loop-comparsion.html":{"url":"doc/javascript/basic/loop-comparsion.html","title":"JavaScript 中几种循环的比较","keywords":"","body":"JavaScript 中几种循环的比较 性能上的比较 通过下面的代码分别在 Chrome 和 Node 环境进行测试： let arr = new Array(100000000).fill(0); console.log('testing...'); let forTimeStart = new Date(); for (let i = 0; i { // nothing to do }) console.log('foreach 循环', new Date() - forEachTime); let mapTime = new Date(); arr.map(() => { // nothing to do }) console.log('map 循环', new Date() - mapTime); Node 环境的结果： Chrome 环境的结果： 可以看到，相比之下，循环速度最快的是缓存 length 的 for 循环，然后普通 for 循环次之，for...in 和 for...of 循环的速度相差不大，最慢的是 map 循环。 如何选择 实际开发中应该选择哪种循环呢？ 在不考虑性能的因素下，应该首先考虑代码的可读性。forEach 和 map 循环代码在实际中的可读性更强一些，所以我们更多的会使用这两种循环。 ES5 中还有很多其他的迭代函数，可根据不同需求进行选择。 如果你需要将数组按照某种规则映射为另一个数组，就应该用 map。 如果你需要进行简单的遍历，用 forEach 或者 for of。 如果你需要对迭代器进行遍历，用 for of. 如果你需要过滤出符合条件的项，用 filter. 如果你需要先按照规则映射为新数组，再根据条件过滤，那就用一个 map 加一个 filter。 作者：黑猫 链接：https://www.zhihu.com/question/263645361/answer/271393425 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 "},"doc/javascript/basic/runtime-mechanic.html":{"url":"doc/javascript/basic/runtime-mechanic.html","title":"JavaScript 运行机制","keywords":"","body":"JavaScript 运行机制 第一个是JavaScript Engine，chrome 的引擎就是 V8（提供调用栈、内存 heap） 第二个是 WEb API，提供一些 dom 操作、ajax 的操作 第三个是 回调队列，也就是Web API 里的回调函数，回放入到回调队列中 第四个是事件循环，也就是宏任务、微任务的容器 call stack 是追踪函数执行流的一种机制，通过调用栈，可以知道当前哪一个函数正在被执行。每当调用一个函数，解释器就将改函数添加至调用栈并开始执行。如果正在执行的函数还调用了其他函数，那么新的函数也会被添加至调用栈中。当调用栈空间被占满时，就会引发“堆栈溢出”。因为只有一个调用栈，所以被称为单线程。 callback queue 回调队列，在 JavaScript 的编译阶段，将一些事件放置在执行队列中。 EventLoop 事件循环 将callback queue 中的事件放在 call stack 中执行 "},"doc/javascript/api/api.html":{"url":"doc/javascript/api/api.html","title":"JavaScript 功能与原理实现","keywords":"","body":"JavaScript 功能与原理实现 "},"doc/computer-network.html":{"url":"doc/computer-network.html","title":"计算机网络","keywords":"","body":"计算机网络 "},"doc/computer-network/http/http.html":{"url":"doc/computer-network/http/http.html","title":"HTTP","keywords":"","body":"HTTP 协议 定义 HTTP（HyperText Transfer Protocol）即超文本传输协议，是一种详细规定了浏览器和万维网服务器之间互相通信的规则，它是万维网交换信息的基础，它允许将 HTML（超文本标记语言）文档从 Web 服务器传送到 Web 浏览器。 HTTP 协议目前最新版的版本是 2.0，HTTP 是一种无状态的协议，无状态是指 Web 浏览器与 Web 服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后 Web 服务器返回响应（Response），连接就被关闭了，在服务器端不保留连接的有关信息。也就是说，HTTP 请求只能由客户端发起，而服务器不能主动向客户端发送数据（2.0 以前）。 工作原理 HTTP 协议工作于客户端-服务端架构上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。 Web 服务器有：Apache 服务器，IIS 服务器（Internet Information Services）等。 Web 服务器根据接收到的请求后，向客户端发送响应信息，HTTP 的默认端口号 80。 相关概念 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 媒体独立：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 请求报文 POST /test.php HTTP/1.1 //请求行 HOST：www.test.com //请求头 User-Agent：Mozilla/5.0 （windows NT 6.1；rv：15.0）Gecko/20100101 Firefox/15.0 //空白行，代表请求头结束 Username=admin&password=admin //请求正文 HTTP 请求包括三部分，分别是请求行（请求方法）、请求头（消息报头）和请求正文。 HTTP 请求第一行为请求行，由三部分组成，第一部分说明了该请求时 POST 请求，第二部分是一个斜杠（/test.php），用来说明请求是该域名根目录下的 test.php，第三部分说明使用的是 HTTP1.1版本。 HTTP 请求第二行至空白行为请求头（也被称为消息头）。其中，HOST代表请求主机地址，User-Agent代表浏览器的标识，请求头由客户端自行设定。 请求正文就是客户端向服务器发送的数据。 请求方法 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 Http常用首部 通用 cache-control ： 控制缓存行为 connection ： 连接的性质，比如keep-alive user-Agent ：用户信息 Date ：报文创建时间 请求 Referrer Policy : 表示来源的（浏览器所访问的前一个页面）,可以用于辅助检测crsf攻击，一般浏览器的默认值是no-referrer-when-downgrade，意思是https降级http的时候不传原地址。 Accept : 能正确接收的媒体类型 Accept-XX(Accept-Charset/Accept-Encoding/Accept-Language):能正确接收的xx Expect :期待服务端的指定行文 If-Match :两端资源标记比较 If-Modified-Since : 比较时间 未修改返回304 Not Modified If-None-Match :比较标记 未修改返回304 Not Modified 响应 Location : 重定向到某个location Server : 服务器名字 Age :响应存在时间 Accept-Ranges ：可以接受的范围类型 响应状态码 1xx：通知 100 客户端重新发起请求 101 更换协议 2xx：成功 200 请求成功 201create 按照客户端请求创建一个新的资源 202Accept 请求无法或不被及时处理 204No Content 请求成功，但是报文不含实体的主体部分 205Reset Content 客户端充值内容 206Partial Content 进行范围请求 3xx：重定向 301 Move Permanently 永久重定向，资源被分配到新的URL 302 Found 临时重定向 303 See Other，表示资源存在另一个URL 304 Not Modified 允许访问资源，和缓存有关 307 Temporary Redirect 临时重定向 4xx：客户端错误 400 请求报文的语法错误 401 没有权限 403 Forbidden 资源存在但被拒绝访问 404 找不到请求的资源 405 Method Not Allowed 不支持的请求方法，比如只支持 Get 5xx：服务器错误 500 服务器内部错误，异常 501 不支持请求的方法 502 Bad Gateway 代理服务器发生问题 503 Server Unavailable 服务器暂时处于超负荷状态 "},"doc/computer-network/http/diff-between-get-post.html":{"url":"doc/computer-network/http/diff-between-get-post.html","title":"GET 和 POST 区别","keywords":"","body":"GET 和 POST 区别 从用法上说，GET 一般用于无副作用、幂等的场景；POST 多用于有副作用、不幂等的情况。 冥等的定义：发送M和N次请求，服务器上资源状态一致。比如说，注册 10 个账号和 11 个账号是不冥等的，对文章进行了 10 次 11 次修改是幂等的，因为前者多了一个账号（资源），后者是更新同一个资源。 副作用的定义：副作用是指对服务器上资源做改变。比如搜索是无副作用的，但更新是有副作用的。 从本质上说，POST 和 GET 都取决于 HTTP，使用哪个方法与应用层传输没有必然的联系。HTTP 没有要求，如果是 POST，数据就要放在 BODY 中。也没有要求 GET，数据（参数）就一定要放在URL中而不能放在BODY中。 细节上有一些区别： Get 能请求缓存，但是 Post 不可以 Post 支持更多编码类型 Get 回退无害，Post 会再次提交 Get 能被保存为书签，Post 不可以 由于浏览器 Url 有限制，所以Get的长度受限，但Post不受限（因为都在Body里） 下面罗列一下 POST 的提交数据方式： application/x-www-form-urlencoded，原生的提交的数据按照key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。 multipart/form-data，表单上传文件时的提交方式 application/json，告诉服务端消息主体是序列化后的 JSON 字符串 text/xml，传输 XML 格式的数据 "},"doc/computer-network/http/what-happend-after-type-url.html":{"url":"doc/computer-network/http/what-happend-after-type-url.html","title":"浏览器的地址栏输入 URL 并按入回车之后发生的过程","keywords":"","body":"浏览器的地址栏输入 URL 并按入回车之后发生的过程 浏览器的地址栏输入 URL 并按下回车。 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期。 DNS 解析 URL 对应的 IP。 根据 IP 建立 TCP 连接（三次握手）。 HTTP 发起请求。 服务器处理请求，浏览器接收 HTTP 响应。 渲染页面，构建 DOM 树。 关闭 TCP 连接（四次挥手）。 "},"doc/computer-network/http/cross-domain.html":{"url":"doc/computer-network/http/cross-domain.html","title":"什么是跨域，如何解决跨域","keywords":"","body":"什么是跨域，如何解决跨域 什么是跨域 当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域。 DOM 具有同源策略，即禁止对不同源页面DOM进行操作。 非同源站点有这样一些限制: 不能读取和修改对方的 DOM 不读访问对方的 Cookie、IndexDB 和 LocalStorage 限制 XMLHttpRequest 请求。 如何解决 1. jsonp 通常为了减轻 web 服务器端压力，我会会把 js、css、html 等静态资源放到另一台独立的域名服务器，在 html 页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 原生实现： var script = document.createElement('script'); script.type = 'text/javascript'; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback'; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) { alert(JSON.stringify(res)); } 以淘宝的扫码登录页面为例，页面会定时轮询服务器判断用户是否扫码，每次轮询都是一次 jsonp 操作，返回一个回调函数，判断扫码状态。 轮询的请求参数如下： 响应回来的是一段 jsonp 代码： // 轮询响应 (function(){jsonp742({\"code\":\"10000\",\"message\":\"login start state\",\"success\":true});})(); 2. document.domain + iframe 如果主域名相同，子域不同，可以设置 docoument.domain 解决跨域问题。 实现原理：因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。 1.）父窗口：(http://www.domain.com/a.html) document.domain = 'domain.com'; var user = 'admin'; 2.）子窗口：(http://child.domain.com/b.html) document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---> ' + window.parent.user); 3. postMessage postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： a.） 页面和其打开的新窗口的数据传递 b.） 多窗口之间消息传递 c.） 页面与嵌套的iframe消息传递 d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数 data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。 origin： 协议+主机+端口号，也可以设置为\"*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。 1.）a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'aym' }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from domain2 ---> ' + e.data); }, false); 2.）b.html：(http://www.domain2.com/b.html) // 接收domain1的数据 window.addEventListener('message', function(e) { alert('data from domain1 ---> ' + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); } }, false); CORS CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。 1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin 【服务端设置】 服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 2、带cookie跨域请求：前后端都需要进行设置 xhr.withCredentials = true; $.ajax({ url: 'http://www.test.com:8080/login', type: 'get', data: {}, xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie }); Nginx 代理 Nginx 是一种高性能的反向代理服务器，可以用来轻松解决跨域问题。 正向代理 帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端。 反向代理 反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的负载均衡，换句话说，反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。 反向代理是一个请求分发的机制，正向代理则是将请求收集。 那么 Nginx 代理是如何解决跨域的呢？ 比如说现在客户端的域名为 domain1.com，服务器的域名为domain2.com，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置: server { listen 80; server_name domain1.com; location /api { proxy_pass domain2.com; } } Nginx 向接收到 domain1.com 的请求，然后作为反向代理，将请求转发给 domain2.com，当响应返回时又将响应给到客户端，这就完成了整个跨域请求的流程。 "},"doc/computer-network/dns/dns.html":{"url":"doc/computer-network/dns/dns.html","title":"DNS","keywords":"","body":"DNS "},"doc/computer-network/dns/dns-resolve.html":{"url":"doc/computer-network/dns/dns-resolve.html","title":"DNS 解析过程","keywords":"","body":"DNS 解析过程 根DNS服务器：返回顶级域名 DNS 服务器的 IP 地址 顶级域DNS服务器：返回权威域名 DNS 服务器的 IP 地址 权威DNS服务器：返回相应主机的 IP 地址 以输入 www.google.com 为例， 浏览器检查自身缓存，有无解析此域名对应的 ip 操作系统缓存 hosts 文件中查询 没有的话，请求本地域名服务器（LDNS）解析域名（一般在城市某处，距离不会太远） 如果还没有的话，就去根 DNS 域服务器查询，此时会给出 .com 的顶级域名服务器 然后去 .com 服务器查询，此时会给出这个域名 google.com 的地址，这是网站注册的域名服务器 去 NameServer 查询，根据映射关系表找到目标 IP,返回给 LDNS（ LDNS 缓存域名及 IP） LDNS 解析结果返回用户（缓存到系统缓存中），域名解析结束 "},"doc/scene-problem.html":{"url":"doc/scene-problem.html","title":"场景问题","keywords":"","body":"场景问题 "},"doc/scene-problem/scan-qrcode-login.html":{"url":"doc/scene-problem/scan-qrcode-login.html","title":"扫码登录的实现原理","keywords":"","body":"扫码登录的实现原理 扫码登录原理 以淘宝为例，当点击扫码登录时，网页首先会请求二维码服务器，生成一张二维码。请求与响应如下图： // 响应 (function(){jsonp31({\"success\":true,\"message\":\"null\",\"url\":\"//img.alicdn.com/imgextra/O1CN01f1PcX71rdZwYau2rM_!!5654-2-xcode.png\",\"lgToken\":\"ca0cc7172af3df24af63ee6ffa30ffca\",\"adToken\":\"aea482731a37b083002fd48d4089ed90\"});})(); 可以看到，响应返回了二维码的URL，以及一个重要的参数lgToken，这是是网页的唯一ID。 这时，网页开始不断的轮询，判断用户是否扫码登录，每次的请求轮询都会将lgToken带上。 轮询的请求参数如下： 响应回来的是一段 jsonp 代码： // 轮询响应 (function(){jsonp742({\"code\":\"10000\",\"message\":\"login start state\",\"success\":true});})(); 当轮询时发现二维码过期时，则轮询停止。响应的 code 为 10004，message 为 QRCode expired!code=1, msg=data not exist // 二维码过期响应 (function(){jsonp2683({\"code\":\"10004\",\"message\":\"QRCode expired!code=1, msg=data not exist\",\"success\":true});})(); 点击刷新二维码，网页会再次请求二维码接口，生成新的二维码，并再次开启轮询。 当用户使用手机扫描二维码后，响应 code 变为10001，并提示扫描成功。 当用户在手机上点击确认登录时，会将用户信息以及二维码上的信息传到服务器并重新生成令牌token。当网页端再次轮询请求接口时，就返回真正的登陆态Token,网页端此时就可以凭着这个Token来登陆了。 "}}